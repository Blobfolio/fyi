/*!
# FYI Msg: Utility Methods
*/

use std::ptr;



#[must_use]
/// # Return Escape Sequence.
///
/// Convert a `u8` number into its equivalent byte string ANSI sequence.
///
/// It is worth noting that unfortunately BASH, et al, work on a 1-256 scale
/// instead of the more typical 0-255 that Rust's `u8` works on. Rather than
/// complicate the logic or require people to mentally subtract one from the
/// value they want, #256 is unsupported.
///
/// ## Examples
///
/// ```
/// assert_eq!(fyi_msg::utility::ansi_code_bold(199), b"\x1B[1;38;5;199m");
/// ```
pub fn ansi_code_bold(num: u8) -> &'static [u8] {
	// Each entry #10-99 is 12 bytes.
	static ANSI_XX: [u8; 1080] = [27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 51, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 52, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 53, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 54, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 55, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 56, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 57, 57, 109];
	// Each entry #100-255 is 13 bytes.
	static ANSI_XXX: [u8; 2028] = [27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 48, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 49, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 50, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 51, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 52, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 53, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 54, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 55, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 56, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 49, 57, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 48, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 49, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 50, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 51, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 53, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 54, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 55, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 56, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 52, 57, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 53, 48, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 53, 49, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 53, 50, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 53, 51, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 53, 52, 109, 27, 91, 49, 59, 51, 56, 59, 53, 59, 50, 53, 53, 109];

	match num {
		1 => b"\x1b[1;38;5;1m",
		2 => b"\x1b[1;38;5;2m",
		3 => b"\x1b[1;38;5;3m",
		4 => b"\x1b[1;38;5;4m",
		5 => b"\x1b[1;38;5;5m",
		6 => b"\x1b[1;38;5;6m",
		7 => b"\x1b[1;38;5;7m",
		8 => b"\x1b[1;38;5;8m",
		9 => b"\x1b[1;38;5;9m",
		10..=99 => {
			let num: usize = (num as usize - 10) * 12;
			&ANSI_XX[num..num+12]
		},
		100..=255 => {
			let num: usize = (num as usize - 100) * 13;
			&ANSI_XXX[num..num+13]
		},
		_ => b"\x1b[0m",
	}
}

/// # Write Double-Digit Time Value.
///
/// This writes a number `0..60` as ASCII-fied bytes, e.g. "00" or "13". Any
/// value over `59` is simply written as "59".
///
/// ## Safety
///
/// This writes two bytes to a mutable pointer; that pointer must be valid and
/// allocated accordingly or undefined things will happen.
pub unsafe fn write_time_dd(ptr: *mut u8, num: u8) {
	static TIME: [u8; 120] = [48, 48, 48, 49, 48, 50, 48, 51, 48, 52, 48, 53, 48, 54, 48, 55, 48, 56, 48, 57, 49, 48, 49, 49, 49, 50, 49, 51, 49, 52, 49, 53, 49, 54, 49, 55, 49, 56, 49, 57, 50, 48, 50, 49, 50, 50, 50, 51, 50, 52, 50, 53, 50, 54, 50, 55, 50, 56, 50, 57, 51, 48, 51, 49, 51, 50, 51, 51, 51, 52, 51, 53, 51, 54, 51, 55, 51, 56, 51, 57, 52, 48, 52, 49, 52, 50, 52, 51, 52, 52, 52, 53, 52, 54, 52, 55, 52, 56, 52, 57, 53, 48, 53, 49, 53, 50, 53, 51, 53, 52, 53, 53, 53, 54, 53, 55, 53, 56, 53, 57];

	std::ptr::copy_nonoverlapping(
		TIME.as_ptr().add((59.min(num) * 2) as usize),
		ptr,
		2
	);
}

/// # Grow `Vec<u8>` From Middle.
///
/// This works like [`std::vec::Vec::resize`], except it supports expansion from the
/// middle, like [`std::vec::Vec::insert`]. The expanded indexes will
/// never be undefined, but may contain copies of data previously occupying
/// those spots (rather than a bunch of zeroes).
///
/// It might seem counter-intuitive to split the resizing and writing
/// operations, but this approach is generally faster than trying to do both at
/// once using [`std::vec::Vec::splice`].
///
/// ## Examples
///
/// ```no_run
/// let mut test: Vec<u8> = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
/// vec_resize_at(&mut test, 4, 5);
/// assert_eq!(
///     test,
///     vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 4, 5, 6, 7, 8, 9],
/// );
/// ```
pub fn vec_resize_at(src: &mut Vec<u8>, idx: usize, adj: usize) {
	let old_len: usize = src.len();
	if idx >= old_len {
		src.resize(old_len + adj, 0);
	}
	else {
		src.reserve(adj);
		unsafe {
			{
				let ptr = src.as_mut_ptr().add(idx);
				let after: usize = old_len - idx;

				// Shift the data over.
				ptr::copy(ptr, ptr.add(adj), after);

				// If we're adding more than we just copied, we'll need to
				// initialize those values.
				if adj > after {
					ptr::write_bytes(ptr.add(after), 0, adj - after);
				}
			}
			src.set_len(old_len + adj);
		}
	}
}



#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn t_ansi_code_bold() {
		assert_eq!(b"\x1b[0m", ansi_code_bold(0));
		for i in 1..=255 {
			assert_eq!(
				ansi_code_bold(i),
				format!("\x1B[1;38;5;{}m", i).as_bytes(),
				"Ansi for {} is incorrect: {:?}",
				i,
				ansi_code_bold(i),
			);
		}
	}

	#[test]
	fn t_time_format_dd() {
		// Test the supported values.
		for i in 0..=59 {
			let mut buf = [0_u8, 0_u8];
			unsafe { write_time_dd(buf.as_mut_ptr(), i); }
			assert_eq!(
				buf,
				format!("{:02}", i).as_bytes(),
				"DD for {} is incorrect: {:?}",
				i,
				buf
			);
		}

		// And make sure overflow works.
		let mut buf = [0_u8, 0_u8];
		unsafe { write_time_dd(buf.as_mut_ptr(), 60); }
		assert_eq!(buf, &b"59"[..]);
	}

	#[test]
	fn t_vec_resize_at() {
		let mut test: Vec<u8> = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
		vec_resize_at(&mut test, 4, 5);
		assert_eq!(
			test,
			vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 4, 5, 6, 7, 8, 9],
		);

		vec_resize_at(&mut test, 15, 5);
		assert_eq!(
			test,
			vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0],
		);

		// Test possible uninit space.
		test = vec![1, 2, 3, 4];
		vec_resize_at(&mut test, 2, 10);
		assert_eq!(
			test,
			vec![1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4],
		);
	}
}
